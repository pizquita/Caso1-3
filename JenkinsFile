pipeline {
    agent any
    environment {
        SAM_CONFIG_PATH = 'repo-config/samconfig.toml'
        ENVIRONMENT = 'staging'  // entorno de despliegue
    }
    options {
        skipDefaultCheckout true
    }
    stages {
        stage('Get Code') {
            steps {
                cleanWs() 
                sh 'echo $WORKSPACE'  // Verifica el workspace
                
               withCredentials([string(credentialsId: 'GitToken', variable: 'GITHUB_TOKEN')]) {
                    git branch: 'develop', 
                        url: "https://oauth2:${GITHUB_TOKEN}@github.com/pizquita/Caso1-3.git"
                }
                
                sh '''
                    ls -la
                    echo $WORKSPACE
                '''
            }
        }
        stage('Static Test') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    sh '''
                        . /opt/venv/jenkins/bin/activate
                        flake8 --format=pylint --exit-zero --output-file=flake8.out src || true
                    '''
                    //cat flake8.out
                    recordIssues tools: [flake8(pattern: 'flake8.out')]
                }
                
               catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE'){
                    sh '''
                        . /opt/venv/jenkins/bin/activate
                        bandit -r src -f json -o bandit.out --exit-zero || true
                    '''
                    recordIssues(tools: [pyLint(name: 'Bandit', pattern: 'bandit.out')])
                    
                }
            }
        }
       stage('Build and Validate') {
            steps {
                script {
                    // Asegurar limpieza previa y clonar el repositorio
                    sh 'rm -rf repo-config' // Asegurar limpieza previa
                    sh 'git clone --branch $ENVIRONMENT https://github.com/pizquita/todo-config.git repo-config'
                    
                    // Verificar que la variable se ha asignado correctamente
                    echo "SAM_CONFIG_PATH set to: ${env.SAM_CONFIG_PATH}"
                    
                    // Mostrar el contenido del archivo para ver si está bien clonado
                    sh "cat ${env.SAM_CONFIG_PATH}"
                    
                    // Validar que el archivo samconfig.toml existe
                    sh 'if [ ! -f $SAM_CONFIG_PATH ]; then echo "samconfig.toml not found!"; exit 1; fi'

                    // Construir la aplicación con AWS SAM
                    sh 'sam build'

                    // Validar la configuración de SAM antes de desplegar
                    sh 'sam validate --region us-east-1'
                }
            }
        }
        stage('Deploy') {
            steps {
                /*//Sección para mostrar en el log la creación del stack
                 sh '''
                    aws cloudformation delete-stack --stack-name todo-list-aws-staging
                    aws cloudformation wait stack-delete-complete --stack-name todo-list-aws-staging
                    sam deploy --resolve-s3 --config-file $SAM_CONFIG_PATH --config-env $ENVIRONMENT --no-confirm-changeset
                '''
                */
                
                 sh "cat $SAM_CONFIG_PATH"
                 
                //solo despliego si detecta cambios en el código
                script {
                    def changes = sh(script: "git diff --quiet || echo 'changed'", returnStdout: true).trim()
                    if (changes == "changed") {
                        echo "Changes detected, proceeding with deployment."
                        sh '''
                            sam deploy --resolve-s3 --config-file $SAM_CONFIG_PATH --config-env $ENVIRONMENT --no-confirm-changeset
                        '''
                    } else {
                        echo "No changes detected, skipping deployment."
                    }
                }
            }
        }
        stage('Rest Test') {
            steps {
                
                script {
                    def apiUrl = sh(script: '''
                        aws cloudformation describe-stacks --stack-name todo-list-aws-staging --query "Stacks[0].Outputs[?OutputKey=='BaseUrlApi'].OutputValue" --output text
                    ''', returnStdout: true).trim()
                    
                    env.BASE_URL = apiUrl
                }
                sh 'echo "BASE_URL: $BASE_URL"' // Para verificar la URL antes de correr los tests
                
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                                        
                    sh '''
                        . /opt/venv/jenkins/bin/activate
                        pytest test/integration/todoApiTest.py --junitxml=result-unit.xml
                    '''
                    junit 'result-unit.xml'
                }
            }
        }
        stage('Promote') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    //Evitamos mergear los jenkinsfile y el archivo de configuración para mantener en cada rama su versión
                    sh '''
                        git status
                        git checkout master
                        git pull origin master  
                        
                        # Fusionar cambios de develop en master sin confirmar
                        git merge --no-commit develop || echo "Conflictos detectados en la fusión"
        
                        # Evitar que se mergee JenkinsFile
                        if git ls-files --unmerged | grep "JenkinsFile"; then
                            echo "Manteniendo la versión de JenkinsFile en master"
                            git checkout --ours JenkinsFile
                            git add JenkinsFile
                        fi
        
                        # Evitar que se mergee Jenkinsfile_agentes
                        if git ls-files --unmerged | grep "Jenkinsfile_agentes"; then
                            echo "Manteniendo la versión de Jenkinsfile_agentes en master"
                            git checkout --ours Jenkinsfile_agentes
                            git add Jenkinsfile_agentes
                        fi
        
                        # Evitar que se suba repo-config
                        git reset HEAD repo-config/ || true  
                        
                        # Verificar si hay cambios pendientes antes de commit
                        if ! git diff-index --quiet HEAD; then
                            git commit -m "Merge develop en master sin JenkinsFile, Jenkinsfile_agentes, ni repo-config"
                        else
                            echo "No hay cambios que confirmar"
                        fi
        
                        # Subir los cambios a master
                        git push origin master
                    '''
                }
            }
        }
    }
}